# 95 MultiThread

- 목적 : 빅 데이터를 소화하기 위해서는 멀티스레드를 활용해야 한다
- 기간 : 2021/11/09 ~ 2021/11/12
- Ref : 
  - 운영체제 / 이화여대 반효경 교수
  - 프로세스와 스레드 : [[영상\]](https://youtu.be/iks_Xb9DtTM)
  - 락 : [[블로그\]](https://popcorntree.tistory.com/84?category=813524)

  - 뮤텍스와 세마포어 : [[블로그\]](https://worthpreading.tistory.com/90) [[블로그\]](https://jwprogramming.tistory.com/13)
  - 데드락 : [[블로그\]](https://chanhuiseok.github.io/posts/cs-2/)
  - 함수형 프로그래밍 : [[얄코\]](https://youtu.be/jVG5jvOzu9Y)
  - 액터모델 : [[영상\]](https://www.youtube.com/watch?v=ELwEdb_pD0k) [[블로그\]](https://github.com/funfunStudy/study/wiki/32장-액터와-동시성)
  



## 프로세스와 스레드

- 프로세스는 독립된 메모리를 갖고, 여러 스레드를 띄울 수 있다.

- 스레드는 프로세스 내의 메모리를 공유한다. 정확하게는, 참조형 변수는 프로세스의 data 에 저장하여 공유하고, 기본형 변수는 스레드의 stack 에 저장하여 함수 내에서만 쓴다.

  <img src="./asset/프로세스와스레드02.PNG" alt="프로세스와스레드" style="zoom:50%;" />

#### 멀티스레드

- 요즘의 운영체제는 다중작업, 시분할 처리방식을 지원한다. 
- CPU 큐에 여러 스레드를 넣어놓고, 아주 빠르게 바꾸어가며 연산을 한다.  
- 병렬적으로 작업할 수 있는 작업 a와, 그걸 처리하는 스레드 여러 개를 CPU 큐에 넣는다면, 
  더 잦은 요청이 들어가고, 더 빠르게 작업을 완료할 수 있다.
- 다만 공유 데이터에 여러 스레드가 접근할 경우 data race 가 발생할 수 있기 때문에,
  락과 함수형 프로그래밍을 활용하는 것이 필요하다.

### 

## 락

- [[블로그\]](https://popcorntree.tistory.com/84?category=813524)

- 한 스레드가 변수 a를 업데이트하고 일을 마쳐야 하는데, 일을 마치기 전에 다른 스레드가 와서 변수 a를 바꿀 수 있다. 이렇게 속도경쟁이 붙을 때 data race라고 한다.

- 해결책은 상호 배제이다. data race가 발생하는 크리티컬 섹션에서는 lock을 써서 상호 배제를 한다. 락을 얻지 못하면 기다리고, 락을 얻은 스레드가 실행이 끝나고 언락을 하면, 기다리던 스레드가 와서 락을 얻어 들어간다.

- 적정한 크기로 락을 거는 게 필요하다. 너무 큰 영역에 락을 걸면 자원을 효율적으로 이용하지 못한다. 반면에 너무 작은 영역에 락을 걸면 성능이 떨어질 수 있다. 왜냐하면 락은 cpu에 부담이 큰 연산인데, 락을 작게 & 여러개로 잡으면 cpu에 부담이 가기 때문이다.

  

#### 뮤텍스, 세마포어

- [[블로그\]](https://worthpreading.tistory.com/90) [[블로그\]](https://jwprogramming.tistory.com/13)

- 락을 거는 아이디어다.

- 공유된 자원 속 하나의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한해 두어야 한다.

- Mutex는 동기화 대상이 오직 하나뿐일 때, Semaphore는 동기화 대상이 하나 이상일 때 사용합니다.

- 뮤텍스 객체와 세마포어 객체는 전역 변수로 둬야 한다.

  ```scala
  // lock
  procedure P(S)           
  	while S=0 do wait        
  	S := S-1                     
  	end P
  
  // unlock
  procedure V(S)          
  	S := S+1                 
  	end V                    
  ```



#### 데드락

- [[블로그\]](https://chanhuiseok.github.io/posts/cs-2/)
- 뮤텍스, 세마포어를 구현할 때에는 데드락에 빠지지 않도록 주의해야 한다.
- 데드락이란, 무한대기에 빠지는 상황이다. 구체적으로는, 자원을 하나 보유했는데 다른 프로세스에 할당된 자원을 점유하기 위해 대기하면서, 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황
- 데드락을 예방하려면 여러 프로세스가 공유 자원을 한번에 사용하도록 허용하는 게 필요하다. 하지만 이건 멀티 스레드, 동기화에 문제가 될 수 있다.
- 그러므로 데드락이 발생하지 않는 순서를 찾거나, 데드락을 탐지하고 회복하는 알고리즘을 짜야 한다.



## 함수형 프로그래밍

- [[얄코\]](https://youtu.be/jVG5jvOzu9Y)

- 코드를 짜는 패러다임이다

- 외부 환경으로부터 철저히 독립적이다

- 외부 변수를 변경할 때에도, 본체를 변경하는 게 아니라 사본을 복사해서 변경을 한다.

- 등장배경

  사용자들의 요구치에 비해 프로세서의 발달이 늦다. 그래서 분산 처리를 해야 했는데, 이때 기존의 명령형 프로그래밍에서는 공유자원이 중간에 변경되는 문제점이 있었다. 이를 해결하기 위해 락을 걸거나, synchronized로 수동으로 처리하기도 했다. 함수형 프로그래밍은 이런 문제를 원천적으로 차단해서 코드를 짜겠다는 것이다.

- 특징

  - 함수형 프로그래밍에서는 외부 변수가 없으므로, 같은 인풋은 같은 아웃풋을 만든다. 이전에는 함수를 동작으로 이해했다면, 함수형 프로그래밍에서는 함수를 값으로 볼 수 있다.
  - 자바에서는 함수의 인자나 결과값에 자료형을 명시했다. 그런데 그 자료형에 함수를 나타내는 것은 없었다. 반면에 함수형 프로그래밍에서는 함수를 값으로 보기 때문에 다른 함수의 인자나, 결과값으로 반환할 수 있다.
  
```scala
  // 인자에 함수를 넣는다
  def calc(num1: Int, num2: Int, op: (Int, Int) => Int): Int 
  	= op(num1, num2)
  def add(num1: Int, num2: Int): Int = num1 + num2
  def multiply(num1: Int, num2: Int): Int = num1 * num2
  def power(num1: Int, num2: Int): Int 
  	= scala.math.pow(num1, num2).toInt
  // 인자와 결과값에 함수를 넣는다.
  def calcWith2(op: (Int, Int) => Int): (Int)=>Int
  	= (num: Int) => op(2, num)
  ```
  
- 커링함수는 인자의 일부분만 채워넣는다. 인자들 일부만 준비되었을 때, 부분 완성된 함수를 마련해두거나 다른 함수에 인자를 넘겨주는 것으로 사용할 수 있다. 로직을 짜는 방식이 더 풍성해지고 코드를 간결하게 짤 수 있다.





