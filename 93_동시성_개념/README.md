# 93 동시성 개념

#### [93_동시성 개념](./93_동시성_개념)

- 목적 : 멀티스레드 프로그램을 구현하는 데 필요한 개념을 이해하자
- 기간 : 2021/11/09 ~ 2021/11/12
- Ref : 
  - 유튜브 얄팍한 코딩사전
  - 기술 블로그



## 스레드와 프로세스

- [[영상\]](https://youtu.be/iks_Xb9DtTM)

- 단일 프로세스라면, 파일을 다운로드하는 동안에는 다른 웹페이지를 켜거나 마우스를 움직일 수 없다. 요즘 컴퓨터는 멀티 프로세스로 일을 한다. 작업 관리자를 켜면 여러 프로세스가 돌아가고 있다.

- 프로세스는 프로그램이 돌아가는 상태이다.

- 멀티 스레드를 구현하려면 concurrency와 parallelism으로 구현한다.

  - 동시성(`Concurrency`) : 싱글 코어에서 멀티 스레드를 동작시키기 위한 방식으로 멀티 태스킹을 위해 여러 개의 스레드가 번갈아가면서 실행되는 성질을 말한다. 동시성을 이용한 싱글 코어의 멀티 태스킹은 각 스레드들이 병렬적으로 실행되는 것처럼 보이지만 사실은 번갈아가면서 조금씩 실행되고 있는 것이다.
  - 병렬성(`Parallelism`) : 멀티 코어에서 멀티 스레드를 동작시키는 방식으로, 한 개 이상의 스레드를 포함하는 각 코어들이 동시에 실행되는 성질을 말한다.

  ![프로세서와스레드](./asset/프로세서와스레드.PNG)

- 웹서버는 대표적인 멀티 스레드다. 브라우저라는 프로세스에다가, 네이버 / 깃 / 노션 등 여러 스레드를 띄울 수 있다.

- 컴퓨터는 프로세스마다 자원을 구분해서 할당한다. 한 프로세스는 여러 스레드로 구성된다. 스레드는 프로세스에 할당된 자원을 공유한다. 이러한 점 때문에 속도와 효율은 좋지만, 동기화 문제가 발생하기도 한다.

- 이런 걸 고려해서 프로그램을 짜야 한다. Actor, Functional Programming, Lambda, Closure는 이를 도와준다.

- java의 synchronized 블록은 한번에 한 스레드만 블록 내 변수에 접근할 수 있도록 한다.

  

## 락

- [[블로그\]](https://popcorntree.tistory.com/84?category=813524)

- 전역 변수는 모든 스레드가 접근할 수 있고, 지역 변수는 해당 스레드에서만 접근할 수 있다.

- 한 스레드가 변수 a를 업데이트하고 일을 마쳐야 하는데, 일을 마치기 전에 다른 스레드가 와서 변수 a를 바꿀 수 있다. 이렇게 속도경쟁이 붙을 때 data race라고 한다.

- 해결책은 상호 배제이다. data race가 발생하는 크리티컬 섹션에서는 lock을 써서 상호 배제를 한다. 락을 얻지 못하면 기다리고, 락을 얻은 스레드가 실행이 끝나고 언락을 하면, 기다리던 스레드가 와서 락을 얻어 들어간다.

- 적정한 크기로 락을 거는 게 필요하다. 너무 큰 영역에 락을 걸면 자원을 효율적으로 이용하지 못한다. 반면에 너무 작은 영역에 락을 걸면 성능이 떨어질 수 있다. 왜냐하면 락은 cpu에 부담이 큰 연산인데, 락을 작게 & 여러개로 잡으면 cpu에 부담이 가기 때문이다.

  

## 뮤텍스, 세마포어

- [[블로그\]](https://worthpreading.tistory.com/90) [[블로그\]](https://jwprogramming.tistory.com/13)

- 공유된 자원 속 하나의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한해 두어야 한다.

- Mutex는 동기화 대상이 오직 하나뿐일 때, Semaphore는 동기화 대상이 하나 이상일 때 사용합니다.

- 뮤텍스와 세마포어는 배제를 위한 아이디어고, 이거를 구현해내는 게 필요하다.

- 뮤텍스 객체와 세마포어 객체는 전역 변수로 둬야 한다.

  ```scala
  // lock
  procedure P(S)           
  	while S=0 do wait        
  	S := S-1                     
  	end P
  
  // unlock
  procedure V(S)          
  	S := S+1                 
  	end V                    
  ```



## 데드락

- [[블로그\]](https://chanhuiseok.github.io/posts/cs-2/)
- 뮤텍스, 세마포어를 구현할 때에는 데드락에 빠지지 않도록 주의해야 한다.
- 데드락이란, 무한대기에 빠지는 상황이다. 구체적으로는, 자원을 하나 보유했는데 다른 프로세스에 할당된 자원을 점유하기 위해 대기하면서, 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황
- 데드락을 예방하려면 여러 프로세스가 공유 자원을 한번에 사용하도록 허용하는 게 필요하다. 하지만 이건 멀티 스레드, 동기화에 문제가 될 수 있다.
- 그러므로 데드락이 발생하지 않는 순서를 찾거나, 데드락을 탐지하고 회복하는 알고리즘을 짜야 한다.



## 함수형 프로그래밍

- [[얄코\]](https://youtu.be/jVG5jvOzu9Y)

- 코드를 짜는 패러다임이다

- 외부 환경으로부터 철저히 독립적이다

- 외부 변수를 변경할 때에도, 본체를 변경하는 게 아니라 사본을 복사해서 변경을 한다.

- 등장배경

  - 사용자들의 요구치에 비해 프로세서의 발달이 늦다. 그래서 분산 처리를 해야 했는데, 이때 기존의 명령형 프로그래밍에서는 공유자원이 중간에 변경되는 문제점이 있었다. 이를 해결하기 위해 락을 걸거나, synchronized로 수동으로 처리하기도 했다. 함수형 프로그래밍은 이런 문제를 원천적으로 차단해서 코드를 짜겠다는 것이다.

- 특징

  - js를 써본 나는 함수형 프로그래밍에 익숙한 개념이 많았다.
  - 함수형 프로그래밍에서는 외부 변수가 없으므로, 같은 인풋은 같은 아웃풋을 만든다. 이전에는 함수를 동작으로 이해했다면, 함수형 프로그래밍에서는 함수를 값으로 볼 수 있다.
  - 자바에서는 함수의 인자나 결과값에 자료형을 명시했다. 그런데 그 자료형에 함수를 나타내는 것은 없었다. 반면에 함수형 프로그래밍에서는 함수를 값으로 보기 때문에 다른 함수의 인자나, 결과값으로 반환할 수 있다.

  ```scala
  // 인자에 함수를 넣는다
  def calc(num1: Int, num2: Int, op: (Int, Int) => Int): Int 
  	= op(num1, num2)
  def add(num1: Int, num2: Int): Int = num1 + num2
  def multiply(num1: Int, num2: Int): Int = num1 * num2
  def power(num1: Int, num2: Int): Int 
  	= scala.math.pow(num1, num2).toInt
  // 인자와 결과값에 함수를 넣는다.
  def calcWith2(op: (Int, Int) => Int): (Int)=>Int
  	= (num: Int) => op(2, num)
  ```

  - 커링함수는 인자의 일부분만 채워넣는다. 인자들 일부만 준비되었을 때, 부분 완성된 함수를 마련해두거나 다른 함수에 인자를 넘겨주는 것으로 사용할 수 있다. 로직을 짜는 방식이 더 풍성해지고 코드를 간결하게 짤 수 있다.



## 액터 모델

- [[영상\]](https://www.youtube.com/watch?v=ELwEdb_pD0k) [[블로그\]](https://github.com/funfunStudy/study/wiki/32장-액터와-동시성)
- 액터는 프로세스와 스레드 사이에 있는 개념 같다.
- Before 원래는 여러 스레드를 왔다갔다 하면서 처리하고 공용 자원은 락을 걸어서 보호했다. (그 부작용으로 처리 시간이 길어지기도 했다)
- After 각 업무에 전문가이며 독립적인 메모리를 갖는 액터들을 만들고 다른 액터에게 맡길 것은 메시지로 보내고 그 메시지는 비동기로 처리해서 뻗지 않게끔 한다.
- 이런 구조로 프로그램을 만들려면 각 액터가 독립적인 전문가가 되도록 전체 구조를 짜는 것 비동기 & concurrent하게 처리되므로 thread safe하게 전체 로직을 짜야한다



